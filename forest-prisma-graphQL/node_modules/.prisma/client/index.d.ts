import {
  DMMF,
  DMMFClass,
  Engine,
  PrismaClientKnownRequestError,
  PrismaClientUnknownRequestError,
  PrismaClientRustPanicError,
  PrismaClientInitializationError,
  PrismaClientValidationError,
  sqltag as sql,
  empty,
  join,
  raw,
  Sql,
} from '@prisma/client/runtime';

export { PrismaClientKnownRequestError }
export { PrismaClientUnknownRequestError }
export { PrismaClientRustPanicError }
export { PrismaClientInitializationError }
export { PrismaClientValidationError }

/**
 * Re-export of sql-template-tag
 */
export { sql, empty, join, raw, Sql }

/**
 * Prisma Client JS version: 2.9.0
 * Query Engine version: 369b3694b7edb869fad14827a33ad3f3f49bbc20
 */
export declare type PrismaVersion = {
  client: string
}

export declare const prismaVersion: PrismaVersion 

/**
 * Utility Types
 */

/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON object.
 * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
 */
export declare type JsonObject = {[Key in string]?: JsonValue}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches a JSON array.
 */
export declare interface JsonArray extends Array<JsonValue> {}
 
/**
 * From https://github.com/sindresorhus/type-fest/
 * Matches any valid JSON value.
 */
export declare type JsonValue = string | number | boolean | null | JsonObject | JsonArray

/**
 * Same as JsonObject, but allows undefined
 */
export declare type InputJsonObject = {[Key in string]?: JsonValue}
 
export declare interface InputJsonArray extends Array<JsonValue> {}
 
export declare type InputJsonValue = undefined |  string | number | boolean | null | InputJsonObject | InputJsonArray

declare type SelectAndInclude = {
  select: any
  include: any
}

declare type HasSelect = {
  select: any
}

declare type HasInclude = {
  include: any
}

declare type CheckSelect<T, S, U> = T extends SelectAndInclude
  ? 'Please either choose `select` or `include`'
  : T extends HasSelect
  ? U
  : T extends HasInclude
  ? U
  : S

/**
 * Get the type of the value, that the Promise holds.
 */
export declare type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

/**
 * Get the return type of a function which returns a Promise.
 */
export declare type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>


export declare type Enumerable<T> = T | Array<T>;

export type RequiredKeys<T> = {
  [K in keyof T]-?: {} extends Pick<T, K> ? never : K
}[keyof T]

export declare type TruthyKeys<T> = {
  [key in keyof T]: T[key] extends false | undefined | null ? never : key
}[keyof T]

export declare type TrueKeys<T> = TruthyKeys<Pick<T, RequiredKeys<T>>>

/**
 * Subset
 * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
 */
export declare type Subset<T, U> = {
  [key in keyof T]: key extends keyof U ? T[key] : never;
};
declare class PrismaClientFetcher {
  private readonly prisma;
  private readonly debug;
  private readonly hooks?;
  constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
  request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
  sanitizeMessage(message: string): string;
  protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
}


/**
 * Client
**/

export declare type Datasource = {
  url?: string
}

export type Datasources = {
  db?: Datasource
}

export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

export interface PrismaClientOptions {
  /**
   * Overwrites the datasource url from your prisma.schema file
   */
  datasources?: Datasources

  /**
   * @default "colorless"
   */
  errorFormat?: ErrorFormat

  /**
   * @example
   * ```
   * // Defaults to stdout
   * log: ['query', 'info', 'warn', 'error']
   * 
   * // Emit as events
   * log: [
   *  { emit: 'stdout', level: 'query' },
   *  { emit: 'stdout', level: 'info' },
   *  { emit: 'stdout', level: 'warn' }
   *  { emit: 'stdout', level: 'error' }
   * ]
   * ```
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
   */
  log?: Array<LogLevel | LogDefinition>
}

export type Hooks = {
  beforeRequest?: (options: {query: string, path: string[], rootField?: string, typeName?: string, document: any}) => any
}

/* Types for Logging */
export type LogLevel = 'info' | 'query' | 'warn' | 'error'
export type LogDefinition = {
  level: LogLevel
  emit: 'stdout' | 'event'
}

export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
  GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
  : never

export type QueryEvent = {
  timestamp: Date
  query: string
  params: string
  duration: number
  target: string
}

export type LogEvent = {
  timestamp: Date
  message: string
  target: string
}
/* End Types for Logging */


export type PrismaAction =
  | 'findOne'
  | 'findMany'
  | 'findFirst'
  | 'create'
  | 'update'
  | 'updateMany'
  | 'upsert'
  | 'delete'
  | 'deleteMany'
  | 'executeRaw'
  | 'queryRaw'
  | 'aggregate'

/**
 * These options are being passed in to the middleware as "params"
 */
export type MiddlewareParams = {
  model?: string
  action: PrismaAction
  args: any
  dataPath: string[]
  runInTransaction: boolean
}

/**
 * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
 */
export type Middleware<T = any> = (
  params: MiddlewareParams,
  next: (params: MiddlewareParams) => Promise<T>,
) => Promise<T>

// tested in getLogLevel.test.ts
export declare function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js (ORM replacement)
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Customers
 * const customers = await prisma.customers.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export declare class PrismaClient<
  T extends PrismaClientOptions = PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<LogLevel | LogDefinition> ? GetEvents<T['log']> : never : never
> {
  /**
   * @private
   */
  private fetcher;
  /**
   * @private
   */
  private readonly dmmf;
  /**
   * @private
   */
  private connectionPromise?;
  /**
   * @private
   */
  private disconnectionPromise?;
  /**
   * @private
   */
  private readonly engineConfig;
  /**
   * @private
   */
  private readonly measurePerformance;
  /**
   * @private
   */
  private engine: Engine;
  /**
   * @private
   */
  private errorFormat: ErrorFormat;

  /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js (ORM replacement)
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Customers
   * const customers = await prisma.customers.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */
  constructor(optionsArg?: T);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * @deprecated renamed to `$on`
   */
  on<V extends U>(eventType: V, callback: (event: V extends 'query' ? QueryEvent : LogEvent) => void): void;
  /**
   * Connect with the database
   */
  $connect(): Promise<void>;
  /**
   * @deprecated renamed to `$connect`
   */
  connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<any>;
  /**
   * @deprecated renamed to `$disconnect`
   */
  disconnect(): Promise<any>;

  /**
   * Add a middleware
   */
  $use(cb: Middleware): void

  /**
   * Executes a raw query and returns the number of affected rows
   * @example
   * ```
   * // With parameters use prisma.executeRaw``, values will be escaped automatically
   * const result = await prisma.executeRaw`UPDATE User SET cool = ${true} WHERE id = ${1};`
   * // Or
   * const result = await prisma.executeRaw('UPDATE User SET cool = $1 WHERE id = $2 ;', true, 1)
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * @deprecated renamed to `$executeRaw`
   */
  executeRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<number>;

  /**
   * Performs a raw query and returns the SELECT data
   * @example
   * ```
   * // With parameters use prisma.queryRaw``, values will be escaped automatically
   * const result = await prisma.queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'ema.il'};`
   * // Or
   * const result = await prisma.queryRaw('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'ema.il')
  * ```
  * 
  * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
  */
  $queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;
 
  /**
   * @deprecated renamed to `$queryRaw`
   */
  queryRaw<T = any>(query: string | TemplateStringsArray, ...values: any[]): Promise<T>;

  /**
   * `prisma.customers`: Exposes CRUD operations for the **customers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customers.findMany()
    * ```
    */
  get customers(): customersDelegate;

  /**
   * `prisma.deliveries`: Exposes CRUD operations for the **deliveries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Deliveries
    * const deliveries = await prisma.deliveries.findMany()
    * ```
    */
  get deliveries(): deliveriesDelegate;

  /**
   * `prisma.orders`: Exposes CRUD operations for the **orders** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Orders
    * const orders = await prisma.orders.findMany()
    * ```
    */
  get orders(): ordersDelegate;

  /**
   * `prisma.products`: Exposes CRUD operations for the **products** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.products.findMany()
    * ```
    */
  get products(): productsDelegate;
}



/**
 * Enums
 */

// Based on
// https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

export declare const CustomersDistinctFieldEnum: {
  id: 'id',
  firstname: 'firstname',
  lastname: 'lastname',
  email: 'email',
  created_at: 'created_at',
  updated_at: 'updated_at',
  stripe_id: 'stripe_id'
};

export declare type CustomersDistinctFieldEnum = (typeof CustomersDistinctFieldEnum)[keyof typeof CustomersDistinctFieldEnum]


export declare const DeliveriesDistinctFieldEnum: {
  id: 'id',
  phone: 'phone',
  lng: 'lng',
  lat: 'lat',
  is_delivered: 'is_delivered',
  created_at: 'created_at',
  updated_at: 'updated_at'
};

export declare type DeliveriesDistinctFieldEnum = (typeof DeliveriesDistinctFieldEnum)[keyof typeof DeliveriesDistinctFieldEnum]


export declare const OrdersDistinctFieldEnum: {
  ref: 'ref',
  shipping_status: 'shipping_status',
  created_at: 'created_at',
  updated_at: 'updated_at',
  product_id: 'product_id',
  customer_id: 'customer_id',
  being_processed_at: 'being_processed_at',
  delivery_id: 'delivery_id',
  ready_for_shipping_at: 'ready_for_shipping_at',
  in_transit_at: 'in_transit_at',
  shipped_at: 'shipped_at'
};

export declare type OrdersDistinctFieldEnum = (typeof OrdersDistinctFieldEnum)[keyof typeof OrdersDistinctFieldEnum]


export declare const ProductsDistinctFieldEnum: {
  id: 'id',
  created_at: 'created_at',
  updated_at: 'updated_at',
  price: 'price',
  label: 'label',
  picture: 'picture'
};

export declare type ProductsDistinctFieldEnum = (typeof ProductsDistinctFieldEnum)[keyof typeof ProductsDistinctFieldEnum]


export declare const SortOrder: {
  asc: 'asc',
  desc: 'desc'
};

export declare type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


export declare const QueryMode: {
  default: 'default',
  insensitive: 'insensitive'
};

export declare type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]



/**
 * Model customers
 */

export type customers = {
  id: number
  firstname: string | null
  lastname: string | null
  email: string | null
  created_at: Date | null
  updated_at: Date | null
  stripe_id: string | null
}


export type AggregateCustomers = {
  count: number
  avg: CustomersAvgAggregateOutputType | null
  sum: CustomersSumAggregateOutputType | null
  min: CustomersMinAggregateOutputType | null
  max: CustomersMaxAggregateOutputType | null
}

export type CustomersAvgAggregateOutputType = {
  id: number
}

export type CustomersSumAggregateOutputType = {
  id: number
}

export type CustomersMinAggregateOutputType = {
  id: number
}

export type CustomersMaxAggregateOutputType = {
  id: number
}


export type CustomersAvgAggregateInputType = {
  id?: true
}

export type CustomersSumAggregateInputType = {
  id?: true
}

export type CustomersMinAggregateInputType = {
  id?: true
}

export type CustomersMaxAggregateInputType = {
  id?: true
}

export type AggregateCustomersArgs = {
  where?: customersWhereInput
  orderBy?: Enumerable<customersOrderByInput> | customersOrderByInput
  cursor?: customersWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<CustomersDistinctFieldEnum>
  count?: true
  avg?: CustomersAvgAggregateInputType
  sum?: CustomersSumAggregateInputType
  min?: CustomersMinAggregateInputType
  max?: CustomersMaxAggregateInputType
}

export type GetCustomersAggregateType<T extends AggregateCustomersArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetCustomersAggregateScalarType<T[P]>
}

export type GetCustomersAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof CustomersAvgAggregateOutputType ? CustomersAvgAggregateOutputType[P] : never
}
    
    

export type customersSelect = {
  id?: boolean
  firstname?: boolean
  lastname?: boolean
  email?: boolean
  created_at?: boolean
  updated_at?: boolean
  stripe_id?: boolean
  orders?: boolean | FindManyordersArgs
}

export type customersInclude = {
  orders?: boolean | FindManyordersArgs
}

export type customersGetPayload<
  S extends boolean | null | undefined | customersArgs,
  U = keyof S
> = S extends true
  ? customers
  : S extends undefined
  ? never
  : S extends customersArgs | FindManycustomersArgs
  ? 'include' extends U
    ? customers  & {
      [P in TrueKeys<S['include']>]:
      P extends 'orders'
      ? Array<ordersGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof customers ? customers[P]
: 
      P extends 'orders'
      ? Array<ordersGetPayload<S['select'][P]>> : never
    }
  : customers
: customers


export interface customersDelegate {
  /**
   * Find zero or one Customers that matches the filter.
   * @param {FindOnecustomersArgs} args - Arguments to find a Customers
   * @example
   * // Get one Customers
   * const customers = await prisma.customers.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnecustomersArgs>(
    args: Subset<T, FindOnecustomersArgs>
  ): CheckSelect<T, Prisma__customersClient<customers | null>, Prisma__customersClient<customersGetPayload<T> | null>>
  /**
   * Find the first Customers that matches the filter.
   * @param {FindFirstcustomersArgs} args - Arguments to find a Customers
   * @example
   * // Get one Customers
   * const customers = await prisma.customers.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstcustomersArgs>(
    args?: Subset<T, FindFirstcustomersArgs>
  ): CheckSelect<T, Prisma__customersClient<customers | null>, Prisma__customersClient<customersGetPayload<T> | null>>
  /**
   * Find zero or more Customers that matches the filter.
   * @param {FindManycustomersArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Customers
   * const customers = await prisma.customers.findMany()
   * 
   * // Get first 10 Customers
   * const customers = await prisma.customers.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const customersWithIdOnly = await prisma.customers.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManycustomersArgs>(
    args?: Subset<T, FindManycustomersArgs>
  ): CheckSelect<T, Promise<Array<customers>>, Promise<Array<customersGetPayload<T>>>>
  /**
   * Create a Customers.
   * @param {customersCreateArgs} args - Arguments to create a Customers.
   * @example
   * // Create one Customers
   * const Customers = await prisma.customers.create({
   *   data: {
   *     // ... data to create a Customers
   *   }
   * })
   * 
  **/
  create<T extends customersCreateArgs>(
    args: Subset<T, customersCreateArgs>
  ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>
  /**
   * Delete a Customers.
   * @param {customersDeleteArgs} args - Arguments to delete one Customers.
   * @example
   * // Delete one Customers
   * const Customers = await prisma.customers.delete({
   *   where: {
   *     // ... filter to delete one Customers
   *   }
   * })
   * 
  **/
  delete<T extends customersDeleteArgs>(
    args: Subset<T, customersDeleteArgs>
  ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>
  /**
   * Update one Customers.
   * @param {customersUpdateArgs} args - Arguments to update one Customers.
   * @example
   * // Update one Customers
   * const customers = await prisma.customers.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends customersUpdateArgs>(
    args: Subset<T, customersUpdateArgs>
  ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>
  /**
   * Delete zero or more Customers.
   * @param {customersDeleteManyArgs} args - Arguments to filter Customers to delete.
   * @example
   * // Delete a few Customers
   * const { count } = await prisma.customers.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends customersDeleteManyArgs>(
    args: Subset<T, customersDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Customers.
   * @param {customersUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Customers
   * const customers = await prisma.customers.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends customersUpdateManyArgs>(
    args: Subset<T, customersUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Customers.
   * @param {customersUpsertArgs} args - Arguments to update or create a Customers.
   * @example
   * // Update or create a Customers
   * const customers = await prisma.customers.upsert({
   *   create: {
   *     // ... data to create a Customers
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Customers we want to update
   *   }
   * })
  **/
  upsert<T extends customersUpsertArgs>(
    args: Subset<T, customersUpsertArgs>
  ): CheckSelect<T, Prisma__customersClient<customers>, Prisma__customersClient<customersGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManycustomersArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateCustomersArgs>(args: Subset<T, AggregateCustomersArgs>): Promise<GetCustomersAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for customers.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__customersClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  orders<T extends FindManyordersArgs = {}>(args?: Subset<T, FindManyordersArgs>): CheckSelect<T, Promise<Array<orders>>, Promise<Array<ordersGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * customers findOne
 */
export type FindOnecustomersArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * Filter, which customers to fetch.
  **/
  where: customersWhereUniqueInput
}


/**
 * customers findFirst
 */
export type FindFirstcustomersArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * Filter, which customers to fetch.
  **/
  where?: customersWhereInput
  orderBy?: Enumerable<customersOrderByInput> | customersOrderByInput
  cursor?: customersWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<CustomersDistinctFieldEnum>
}


/**
 * customers findMany
 */
export type FindManycustomersArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * Filter, which customers to fetch.
  **/
  where?: customersWhereInput
  /**
   * Determine the order of the customers to fetch.
  **/
  orderBy?: Enumerable<customersOrderByInput> | customersOrderByInput
  /**
   * Sets the position for listing customers.
  **/
  cursor?: customersWhereUniqueInput
  /**
   * The number of customers to fetch. If negative number, it will take customers before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` customers.
  **/
  skip?: number
  distinct?: Enumerable<CustomersDistinctFieldEnum>
}


/**
 * customers create
 */
export type customersCreateArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * The data needed to create a customers.
  **/
  data: customersCreateInput
}


/**
 * customers update
 */
export type customersUpdateArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * The data needed to update a customers.
  **/
  data: customersUpdateInput
  /**
   * Choose, which customers to update.
  **/
  where: customersWhereUniqueInput
}


/**
 * customers updateMany
 */
export type customersUpdateManyArgs = {
  data: customersUpdateManyMutationInput
  where?: customersWhereInput
}


/**
 * customers upsert
 */
export type customersUpsertArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * The filter to search for the customers to update in case it exists.
  **/
  where: customersWhereUniqueInput
  /**
   * In case the customers found by the `where` argument doesn't exist, create a new customers with this data.
  **/
  create: customersCreateInput
  /**
   * In case the customers was found with the provided `where` argument, update it with this data.
  **/
  update: customersUpdateInput
}


/**
 * customers delete
 */
export type customersDeleteArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
  /**
   * Filter which customers to delete.
  **/
  where: customersWhereUniqueInput
}


/**
 * customers deleteMany
 */
export type customersDeleteManyArgs = {
  where?: customersWhereInput
}


/**
 * customers without action
 */
export type customersArgs = {
  /**
   * Select specific fields to fetch from the customers
  **/
  select?: customersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: customersInclude | null
}



/**
 * Model deliveries
 */

export type deliveries = {
  id: number
  phone: string | null
  lng: number | null
  lat: number | null
  is_delivered: boolean | null
  created_at: Date | null
  updated_at: Date | null
}


export type AggregateDeliveries = {
  count: number
  avg: DeliveriesAvgAggregateOutputType | null
  sum: DeliveriesSumAggregateOutputType | null
  min: DeliveriesMinAggregateOutputType | null
  max: DeliveriesMaxAggregateOutputType | null
}

export type DeliveriesAvgAggregateOutputType = {
  id: number
  lng: number | null
  lat: number | null
}

export type DeliveriesSumAggregateOutputType = {
  id: number
  lng: number | null
  lat: number | null
}

export type DeliveriesMinAggregateOutputType = {
  id: number
  lng: number | null
  lat: number | null
}

export type DeliveriesMaxAggregateOutputType = {
  id: number
  lng: number | null
  lat: number | null
}


export type DeliveriesAvgAggregateInputType = {
  id?: true
  lng?: true
  lat?: true
}

export type DeliveriesSumAggregateInputType = {
  id?: true
  lng?: true
  lat?: true
}

export type DeliveriesMinAggregateInputType = {
  id?: true
  lng?: true
  lat?: true
}

export type DeliveriesMaxAggregateInputType = {
  id?: true
  lng?: true
  lat?: true
}

export type AggregateDeliveriesArgs = {
  where?: deliveriesWhereInput
  orderBy?: Enumerable<deliveriesOrderByInput> | deliveriesOrderByInput
  cursor?: deliveriesWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DeliveriesDistinctFieldEnum>
  count?: true
  avg?: DeliveriesAvgAggregateInputType
  sum?: DeliveriesSumAggregateInputType
  min?: DeliveriesMinAggregateInputType
  max?: DeliveriesMaxAggregateInputType
}

export type GetDeliveriesAggregateType<T extends AggregateDeliveriesArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetDeliveriesAggregateScalarType<T[P]>
}

export type GetDeliveriesAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof DeliveriesAvgAggregateOutputType ? DeliveriesAvgAggregateOutputType[P] : never
}
    
    

export type deliveriesSelect = {
  id?: boolean
  phone?: boolean
  lng?: boolean
  lat?: boolean
  is_delivered?: boolean
  created_at?: boolean
  updated_at?: boolean
  orders?: boolean | FindManyordersArgs
}

export type deliveriesInclude = {
  orders?: boolean | FindManyordersArgs
}

export type deliveriesGetPayload<
  S extends boolean | null | undefined | deliveriesArgs,
  U = keyof S
> = S extends true
  ? deliveries
  : S extends undefined
  ? never
  : S extends deliveriesArgs | FindManydeliveriesArgs
  ? 'include' extends U
    ? deliveries  & {
      [P in TrueKeys<S['include']>]:
      P extends 'orders'
      ? Array<ordersGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof deliveries ? deliveries[P]
: 
      P extends 'orders'
      ? Array<ordersGetPayload<S['select'][P]>> : never
    }
  : deliveries
: deliveries


export interface deliveriesDelegate {
  /**
   * Find zero or one Deliveries that matches the filter.
   * @param {FindOnedeliveriesArgs} args - Arguments to find a Deliveries
   * @example
   * // Get one Deliveries
   * const deliveries = await prisma.deliveries.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOnedeliveriesArgs>(
    args: Subset<T, FindOnedeliveriesArgs>
  ): CheckSelect<T, Prisma__deliveriesClient<deliveries | null>, Prisma__deliveriesClient<deliveriesGetPayload<T> | null>>
  /**
   * Find the first Deliveries that matches the filter.
   * @param {FindFirstdeliveriesArgs} args - Arguments to find a Deliveries
   * @example
   * // Get one Deliveries
   * const deliveries = await prisma.deliveries.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstdeliveriesArgs>(
    args?: Subset<T, FindFirstdeliveriesArgs>
  ): CheckSelect<T, Prisma__deliveriesClient<deliveries | null>, Prisma__deliveriesClient<deliveriesGetPayload<T> | null>>
  /**
   * Find zero or more Deliveries that matches the filter.
   * @param {FindManydeliveriesArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Deliveries
   * const deliveries = await prisma.deliveries.findMany()
   * 
   * // Get first 10 Deliveries
   * const deliveries = await prisma.deliveries.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const deliveriesWithIdOnly = await prisma.deliveries.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManydeliveriesArgs>(
    args?: Subset<T, FindManydeliveriesArgs>
  ): CheckSelect<T, Promise<Array<deliveries>>, Promise<Array<deliveriesGetPayload<T>>>>
  /**
   * Create a Deliveries.
   * @param {deliveriesCreateArgs} args - Arguments to create a Deliveries.
   * @example
   * // Create one Deliveries
   * const Deliveries = await prisma.deliveries.create({
   *   data: {
   *     // ... data to create a Deliveries
   *   }
   * })
   * 
  **/
  create<T extends deliveriesCreateArgs>(
    args: Subset<T, deliveriesCreateArgs>
  ): CheckSelect<T, Prisma__deliveriesClient<deliveries>, Prisma__deliveriesClient<deliveriesGetPayload<T>>>
  /**
   * Delete a Deliveries.
   * @param {deliveriesDeleteArgs} args - Arguments to delete one Deliveries.
   * @example
   * // Delete one Deliveries
   * const Deliveries = await prisma.deliveries.delete({
   *   where: {
   *     // ... filter to delete one Deliveries
   *   }
   * })
   * 
  **/
  delete<T extends deliveriesDeleteArgs>(
    args: Subset<T, deliveriesDeleteArgs>
  ): CheckSelect<T, Prisma__deliveriesClient<deliveries>, Prisma__deliveriesClient<deliveriesGetPayload<T>>>
  /**
   * Update one Deliveries.
   * @param {deliveriesUpdateArgs} args - Arguments to update one Deliveries.
   * @example
   * // Update one Deliveries
   * const deliveries = await prisma.deliveries.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends deliveriesUpdateArgs>(
    args: Subset<T, deliveriesUpdateArgs>
  ): CheckSelect<T, Prisma__deliveriesClient<deliveries>, Prisma__deliveriesClient<deliveriesGetPayload<T>>>
  /**
   * Delete zero or more Deliveries.
   * @param {deliveriesDeleteManyArgs} args - Arguments to filter Deliveries to delete.
   * @example
   * // Delete a few Deliveries
   * const { count } = await prisma.deliveries.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends deliveriesDeleteManyArgs>(
    args: Subset<T, deliveriesDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Deliveries.
   * @param {deliveriesUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Deliveries
   * const deliveries = await prisma.deliveries.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends deliveriesUpdateManyArgs>(
    args: Subset<T, deliveriesUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Deliveries.
   * @param {deliveriesUpsertArgs} args - Arguments to update or create a Deliveries.
   * @example
   * // Update or create a Deliveries
   * const deliveries = await prisma.deliveries.upsert({
   *   create: {
   *     // ... data to create a Deliveries
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Deliveries we want to update
   *   }
   * })
  **/
  upsert<T extends deliveriesUpsertArgs>(
    args: Subset<T, deliveriesUpsertArgs>
  ): CheckSelect<T, Prisma__deliveriesClient<deliveries>, Prisma__deliveriesClient<deliveriesGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManydeliveriesArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateDeliveriesArgs>(args: Subset<T, AggregateDeliveriesArgs>): Promise<GetDeliveriesAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for deliveries.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__deliveriesClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  orders<T extends FindManyordersArgs = {}>(args?: Subset<T, FindManyordersArgs>): CheckSelect<T, Promise<Array<orders>>, Promise<Array<ordersGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * deliveries findOne
 */
export type FindOnedeliveriesArgs = {
  /**
   * Select specific fields to fetch from the deliveries
  **/
  select?: deliveriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: deliveriesInclude | null
  /**
   * Filter, which deliveries to fetch.
  **/
  where: deliveriesWhereUniqueInput
}


/**
 * deliveries findFirst
 */
export type FindFirstdeliveriesArgs = {
  /**
   * Select specific fields to fetch from the deliveries
  **/
  select?: deliveriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: deliveriesInclude | null
  /**
   * Filter, which deliveries to fetch.
  **/
  where?: deliveriesWhereInput
  orderBy?: Enumerable<deliveriesOrderByInput> | deliveriesOrderByInput
  cursor?: deliveriesWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<DeliveriesDistinctFieldEnum>
}


/**
 * deliveries findMany
 */
export type FindManydeliveriesArgs = {
  /**
   * Select specific fields to fetch from the deliveries
  **/
  select?: deliveriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: deliveriesInclude | null
  /**
   * Filter, which deliveries to fetch.
  **/
  where?: deliveriesWhereInput
  /**
   * Determine the order of the deliveries to fetch.
  **/
  orderBy?: Enumerable<deliveriesOrderByInput> | deliveriesOrderByInput
  /**
   * Sets the position for listing deliveries.
  **/
  cursor?: deliveriesWhereUniqueInput
  /**
   * The number of deliveries to fetch. If negative number, it will take deliveries before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` deliveries.
  **/
  skip?: number
  distinct?: Enumerable<DeliveriesDistinctFieldEnum>
}


/**
 * deliveries create
 */
export type deliveriesCreateArgs = {
  /**
   * Select specific fields to fetch from the deliveries
  **/
  select?: deliveriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: deliveriesInclude | null
  /**
   * The data needed to create a deliveries.
  **/
  data: deliveriesCreateInput
}


/**
 * deliveries update
 */
export type deliveriesUpdateArgs = {
  /**
   * Select specific fields to fetch from the deliveries
  **/
  select?: deliveriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: deliveriesInclude | null
  /**
   * The data needed to update a deliveries.
  **/
  data: deliveriesUpdateInput
  /**
   * Choose, which deliveries to update.
  **/
  where: deliveriesWhereUniqueInput
}


/**
 * deliveries updateMany
 */
export type deliveriesUpdateManyArgs = {
  data: deliveriesUpdateManyMutationInput
  where?: deliveriesWhereInput
}


/**
 * deliveries upsert
 */
export type deliveriesUpsertArgs = {
  /**
   * Select specific fields to fetch from the deliveries
  **/
  select?: deliveriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: deliveriesInclude | null
  /**
   * The filter to search for the deliveries to update in case it exists.
  **/
  where: deliveriesWhereUniqueInput
  /**
   * In case the deliveries found by the `where` argument doesn't exist, create a new deliveries with this data.
  **/
  create: deliveriesCreateInput
  /**
   * In case the deliveries was found with the provided `where` argument, update it with this data.
  **/
  update: deliveriesUpdateInput
}


/**
 * deliveries delete
 */
export type deliveriesDeleteArgs = {
  /**
   * Select specific fields to fetch from the deliveries
  **/
  select?: deliveriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: deliveriesInclude | null
  /**
   * Filter which deliveries to delete.
  **/
  where: deliveriesWhereUniqueInput
}


/**
 * deliveries deleteMany
 */
export type deliveriesDeleteManyArgs = {
  where?: deliveriesWhereInput
}


/**
 * deliveries without action
 */
export type deliveriesArgs = {
  /**
   * Select specific fields to fetch from the deliveries
  **/
  select?: deliveriesSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: deliveriesInclude | null
}



/**
 * Model orders
 */

export type orders = {
  ref: string
  shipping_status: string | null
  created_at: Date | null
  updated_at: Date | null
  product_id: number | null
  customer_id: number | null
  being_processed_at: Date | null
  delivery_id: number | null
  ready_for_shipping_at: Date | null
  in_transit_at: Date | null
  shipped_at: Date | null
}


export type AggregateOrders = {
  count: number
  avg: OrdersAvgAggregateOutputType | null
  sum: OrdersSumAggregateOutputType | null
  min: OrdersMinAggregateOutputType | null
  max: OrdersMaxAggregateOutputType | null
}

export type OrdersAvgAggregateOutputType = {
  product_id: number | null
  customer_id: number | null
  delivery_id: number | null
}

export type OrdersSumAggregateOutputType = {
  product_id: number | null
  customer_id: number | null
  delivery_id: number | null
}

export type OrdersMinAggregateOutputType = {
  product_id: number | null
  customer_id: number | null
  delivery_id: number | null
}

export type OrdersMaxAggregateOutputType = {
  product_id: number | null
  customer_id: number | null
  delivery_id: number | null
}


export type OrdersAvgAggregateInputType = {
  product_id?: true
  customer_id?: true
  delivery_id?: true
}

export type OrdersSumAggregateInputType = {
  product_id?: true
  customer_id?: true
  delivery_id?: true
}

export type OrdersMinAggregateInputType = {
  product_id?: true
  customer_id?: true
  delivery_id?: true
}

export type OrdersMaxAggregateInputType = {
  product_id?: true
  customer_id?: true
  delivery_id?: true
}

export type AggregateOrdersArgs = {
  where?: ordersWhereInput
  orderBy?: Enumerable<ordersOrderByInput> | ordersOrderByInput
  cursor?: ordersWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OrdersDistinctFieldEnum>
  count?: true
  avg?: OrdersAvgAggregateInputType
  sum?: OrdersSumAggregateInputType
  min?: OrdersMinAggregateInputType
  max?: OrdersMaxAggregateInputType
}

export type GetOrdersAggregateType<T extends AggregateOrdersArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetOrdersAggregateScalarType<T[P]>
}

export type GetOrdersAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof OrdersAvgAggregateOutputType ? OrdersAvgAggregateOutputType[P] : never
}
    
    

export type ordersSelect = {
  ref?: boolean
  shipping_status?: boolean
  created_at?: boolean
  updated_at?: boolean
  product_id?: boolean
  customer_id?: boolean
  being_processed_at?: boolean
  delivery_id?: boolean
  ready_for_shipping_at?: boolean
  in_transit_at?: boolean
  shipped_at?: boolean
  customers?: boolean | customersArgs
  deliveries?: boolean | deliveriesArgs
  products?: boolean | productsArgs
}

export type ordersInclude = {
  customers?: boolean | customersArgs
  deliveries?: boolean | deliveriesArgs
  products?: boolean | productsArgs
}

export type ordersGetPayload<
  S extends boolean | null | undefined | ordersArgs,
  U = keyof S
> = S extends true
  ? orders
  : S extends undefined
  ? never
  : S extends ordersArgs | FindManyordersArgs
  ? 'include' extends U
    ? orders  & {
      [P in TrueKeys<S['include']>]:
      P extends 'customers'
      ? customersGetPayload<S['include'][P]> | null :
      P extends 'deliveries'
      ? deliveriesGetPayload<S['include'][P]> | null :
      P extends 'products'
      ? productsGetPayload<S['include'][P]> | null : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof orders ? orders[P]
: 
      P extends 'customers'
      ? customersGetPayload<S['select'][P]> | null :
      P extends 'deliveries'
      ? deliveriesGetPayload<S['select'][P]> | null :
      P extends 'products'
      ? productsGetPayload<S['select'][P]> | null : never
    }
  : orders
: orders


export interface ordersDelegate {
  /**
   * Find zero or one Orders that matches the filter.
   * @param {FindOneordersArgs} args - Arguments to find a Orders
   * @example
   * // Get one Orders
   * const orders = await prisma.orders.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneordersArgs>(
    args: Subset<T, FindOneordersArgs>
  ): CheckSelect<T, Prisma__ordersClient<orders | null>, Prisma__ordersClient<ordersGetPayload<T> | null>>
  /**
   * Find the first Orders that matches the filter.
   * @param {FindFirstordersArgs} args - Arguments to find a Orders
   * @example
   * // Get one Orders
   * const orders = await prisma.orders.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstordersArgs>(
    args?: Subset<T, FindFirstordersArgs>
  ): CheckSelect<T, Prisma__ordersClient<orders | null>, Prisma__ordersClient<ordersGetPayload<T> | null>>
  /**
   * Find zero or more Orders that matches the filter.
   * @param {FindManyordersArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Orders
   * const orders = await prisma.orders.findMany()
   * 
   * // Get first 10 Orders
   * const orders = await prisma.orders.findMany({ take: 10 })
   * 
   * // Only select the `ref`
   * const ordersWithRefOnly = await prisma.orders.findMany({ select: { ref: true } })
   * 
  **/
  findMany<T extends FindManyordersArgs>(
    args?: Subset<T, FindManyordersArgs>
  ): CheckSelect<T, Promise<Array<orders>>, Promise<Array<ordersGetPayload<T>>>>
  /**
   * Create a Orders.
   * @param {ordersCreateArgs} args - Arguments to create a Orders.
   * @example
   * // Create one Orders
   * const Orders = await prisma.orders.create({
   *   data: {
   *     // ... data to create a Orders
   *   }
   * })
   * 
  **/
  create<T extends ordersCreateArgs>(
    args: Subset<T, ordersCreateArgs>
  ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>
  /**
   * Delete a Orders.
   * @param {ordersDeleteArgs} args - Arguments to delete one Orders.
   * @example
   * // Delete one Orders
   * const Orders = await prisma.orders.delete({
   *   where: {
   *     // ... filter to delete one Orders
   *   }
   * })
   * 
  **/
  delete<T extends ordersDeleteArgs>(
    args: Subset<T, ordersDeleteArgs>
  ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>
  /**
   * Update one Orders.
   * @param {ordersUpdateArgs} args - Arguments to update one Orders.
   * @example
   * // Update one Orders
   * const orders = await prisma.orders.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends ordersUpdateArgs>(
    args: Subset<T, ordersUpdateArgs>
  ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>
  /**
   * Delete zero or more Orders.
   * @param {ordersDeleteManyArgs} args - Arguments to filter Orders to delete.
   * @example
   * // Delete a few Orders
   * const { count } = await prisma.orders.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends ordersDeleteManyArgs>(
    args: Subset<T, ordersDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Orders.
   * @param {ordersUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Orders
   * const orders = await prisma.orders.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends ordersUpdateManyArgs>(
    args: Subset<T, ordersUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Orders.
   * @param {ordersUpsertArgs} args - Arguments to update or create a Orders.
   * @example
   * // Update or create a Orders
   * const orders = await prisma.orders.upsert({
   *   create: {
   *     // ... data to create a Orders
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Orders we want to update
   *   }
   * })
  **/
  upsert<T extends ordersUpsertArgs>(
    args: Subset<T, ordersUpsertArgs>
  ): CheckSelect<T, Prisma__ordersClient<orders>, Prisma__ordersClient<ordersGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyordersArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateOrdersArgs>(args: Subset<T, AggregateOrdersArgs>): Promise<GetOrdersAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for orders.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__ordersClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  customers<T extends customersArgs = {}>(args?: Subset<T, customersArgs>): CheckSelect<T, Prisma__customersClient<customers | null>, Prisma__customersClient<customersGetPayload<T> | null>>;

  deliveries<T extends deliveriesArgs = {}>(args?: Subset<T, deliveriesArgs>): CheckSelect<T, Prisma__deliveriesClient<deliveries | null>, Prisma__deliveriesClient<deliveriesGetPayload<T> | null>>;

  products<T extends productsArgs = {}>(args?: Subset<T, productsArgs>): CheckSelect<T, Prisma__productsClient<products | null>, Prisma__productsClient<productsGetPayload<T> | null>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * orders findOne
 */
export type FindOneordersArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * Filter, which orders to fetch.
  **/
  where: ordersWhereUniqueInput
}


/**
 * orders findFirst
 */
export type FindFirstordersArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * Filter, which orders to fetch.
  **/
  where?: ordersWhereInput
  orderBy?: Enumerable<ordersOrderByInput> | ordersOrderByInput
  cursor?: ordersWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<OrdersDistinctFieldEnum>
}


/**
 * orders findMany
 */
export type FindManyordersArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * Filter, which orders to fetch.
  **/
  where?: ordersWhereInput
  /**
   * Determine the order of the orders to fetch.
  **/
  orderBy?: Enumerable<ordersOrderByInput> | ordersOrderByInput
  /**
   * Sets the position for listing orders.
  **/
  cursor?: ordersWhereUniqueInput
  /**
   * The number of orders to fetch. If negative number, it will take orders before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` orders.
  **/
  skip?: number
  distinct?: Enumerable<OrdersDistinctFieldEnum>
}


/**
 * orders create
 */
export type ordersCreateArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * The data needed to create a orders.
  **/
  data: ordersCreateInput
}


/**
 * orders update
 */
export type ordersUpdateArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * The data needed to update a orders.
  **/
  data: ordersUpdateInput
  /**
   * Choose, which orders to update.
  **/
  where: ordersWhereUniqueInput
}


/**
 * orders updateMany
 */
export type ordersUpdateManyArgs = {
  data: ordersUpdateManyMutationInput
  where?: ordersWhereInput
}


/**
 * orders upsert
 */
export type ordersUpsertArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * The filter to search for the orders to update in case it exists.
  **/
  where: ordersWhereUniqueInput
  /**
   * In case the orders found by the `where` argument doesn't exist, create a new orders with this data.
  **/
  create: ordersCreateInput
  /**
   * In case the orders was found with the provided `where` argument, update it with this data.
  **/
  update: ordersUpdateInput
}


/**
 * orders delete
 */
export type ordersDeleteArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
  /**
   * Filter which orders to delete.
  **/
  where: ordersWhereUniqueInput
}


/**
 * orders deleteMany
 */
export type ordersDeleteManyArgs = {
  where?: ordersWhereInput
}


/**
 * orders without action
 */
export type ordersArgs = {
  /**
   * Select specific fields to fetch from the orders
  **/
  select?: ordersSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: ordersInclude | null
}



/**
 * Model products
 */

export type products = {
  id: number
  created_at: Date | null
  updated_at: Date | null
  price: number | null
  label: string | null
  picture: string | null
}


export type AggregateProducts = {
  count: number
  avg: ProductsAvgAggregateOutputType | null
  sum: ProductsSumAggregateOutputType | null
  min: ProductsMinAggregateOutputType | null
  max: ProductsMaxAggregateOutputType | null
}

export type ProductsAvgAggregateOutputType = {
  id: number
  price: number | null
}

export type ProductsSumAggregateOutputType = {
  id: number
  price: number | null
}

export type ProductsMinAggregateOutputType = {
  id: number
  price: number | null
}

export type ProductsMaxAggregateOutputType = {
  id: number
  price: number | null
}


export type ProductsAvgAggregateInputType = {
  id?: true
  price?: true
}

export type ProductsSumAggregateInputType = {
  id?: true
  price?: true
}

export type ProductsMinAggregateInputType = {
  id?: true
  price?: true
}

export type ProductsMaxAggregateInputType = {
  id?: true
  price?: true
}

export type AggregateProductsArgs = {
  where?: productsWhereInput
  orderBy?: Enumerable<productsOrderByInput> | productsOrderByInput
  cursor?: productsWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ProductsDistinctFieldEnum>
  count?: true
  avg?: ProductsAvgAggregateInputType
  sum?: ProductsSumAggregateInputType
  min?: ProductsMinAggregateInputType
  max?: ProductsMaxAggregateInputType
}

export type GetProductsAggregateType<T extends AggregateProductsArgs> = {
  [P in keyof T]: P extends 'count' ? number : GetProductsAggregateScalarType<T[P]>
}

export type GetProductsAggregateScalarType<T extends any> = {
  [P in keyof T]: P extends keyof ProductsAvgAggregateOutputType ? ProductsAvgAggregateOutputType[P] : never
}
    
    

export type productsSelect = {
  id?: boolean
  created_at?: boolean
  updated_at?: boolean
  price?: boolean
  label?: boolean
  picture?: boolean
  orders?: boolean | FindManyordersArgs
}

export type productsInclude = {
  orders?: boolean | FindManyordersArgs
}

export type productsGetPayload<
  S extends boolean | null | undefined | productsArgs,
  U = keyof S
> = S extends true
  ? products
  : S extends undefined
  ? never
  : S extends productsArgs | FindManyproductsArgs
  ? 'include' extends U
    ? products  & {
      [P in TrueKeys<S['include']>]:
      P extends 'orders'
      ? Array<ordersGetPayload<S['include'][P]>> : never
    }
  : 'select' extends U
    ? {
      [P in TrueKeys<S['select']>]:P extends keyof products ? products[P]
: 
      P extends 'orders'
      ? Array<ordersGetPayload<S['select'][P]>> : never
    }
  : products
: products


export interface productsDelegate {
  /**
   * Find zero or one Products that matches the filter.
   * @param {FindOneproductsArgs} args - Arguments to find a Products
   * @example
   * // Get one Products
   * const products = await prisma.products.findOne({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findOne<T extends FindOneproductsArgs>(
    args: Subset<T, FindOneproductsArgs>
  ): CheckSelect<T, Prisma__productsClient<products | null>, Prisma__productsClient<productsGetPayload<T> | null>>
  /**
   * Find the first Products that matches the filter.
   * @param {FindFirstproductsArgs} args - Arguments to find a Products
   * @example
   * // Get one Products
   * const products = await prisma.products.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
  **/
  findFirst<T extends FindFirstproductsArgs>(
    args?: Subset<T, FindFirstproductsArgs>
  ): CheckSelect<T, Prisma__productsClient<products | null>, Prisma__productsClient<productsGetPayload<T> | null>>
  /**
   * Find zero or more Products that matches the filter.
   * @param {FindManyproductsArgs=} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Products
   * const products = await prisma.products.findMany()
   * 
   * // Get first 10 Products
   * const products = await prisma.products.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const productsWithIdOnly = await prisma.products.findMany({ select: { id: true } })
   * 
  **/
  findMany<T extends FindManyproductsArgs>(
    args?: Subset<T, FindManyproductsArgs>
  ): CheckSelect<T, Promise<Array<products>>, Promise<Array<productsGetPayload<T>>>>
  /**
   * Create a Products.
   * @param {productsCreateArgs} args - Arguments to create a Products.
   * @example
   * // Create one Products
   * const Products = await prisma.products.create({
   *   data: {
   *     // ... data to create a Products
   *   }
   * })
   * 
  **/
  create<T extends productsCreateArgs>(
    args: Subset<T, productsCreateArgs>
  ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>
  /**
   * Delete a Products.
   * @param {productsDeleteArgs} args - Arguments to delete one Products.
   * @example
   * // Delete one Products
   * const Products = await prisma.products.delete({
   *   where: {
   *     // ... filter to delete one Products
   *   }
   * })
   * 
  **/
  delete<T extends productsDeleteArgs>(
    args: Subset<T, productsDeleteArgs>
  ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>
  /**
   * Update one Products.
   * @param {productsUpdateArgs} args - Arguments to update one Products.
   * @example
   * // Update one Products
   * const products = await prisma.products.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  update<T extends productsUpdateArgs>(
    args: Subset<T, productsUpdateArgs>
  ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>
  /**
   * Delete zero or more Products.
   * @param {productsDeleteManyArgs} args - Arguments to filter Products to delete.
   * @example
   * // Delete a few Products
   * const { count } = await prisma.products.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
  **/
  deleteMany<T extends productsDeleteManyArgs>(
    args: Subset<T, productsDeleteManyArgs>
  ): Promise<BatchPayload>
  /**
   * Update zero or more Products.
   * @param {productsUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Products
   * const products = await prisma.products.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
  **/
  updateMany<T extends productsUpdateManyArgs>(
    args: Subset<T, productsUpdateManyArgs>
  ): Promise<BatchPayload>
  /**
   * Create or update one Products.
   * @param {productsUpsertArgs} args - Arguments to update or create a Products.
   * @example
   * // Update or create a Products
   * const products = await prisma.products.upsert({
   *   create: {
   *     // ... data to create a Products
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Products we want to update
   *   }
   * })
  **/
  upsert<T extends productsUpsertArgs>(
    args: Subset<T, productsUpsertArgs>
  ): CheckSelect<T, Prisma__productsClient<products>, Prisma__productsClient<productsGetPayload<T>>>
  /**
   * Count
   */
  count(args?: Omit<FindManyproductsArgs, 'select' | 'include'>): Promise<number>

  /**
   * Aggregate
   */
  aggregate<T extends AggregateProductsArgs>(args: Subset<T, AggregateProductsArgs>): Promise<GetProductsAggregateType<T>>
}

/**
 * The delegate class that acts as a "Promise-like" for products.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in 
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export declare class Prisma__productsClient<T> implements Promise<T> {
  private readonly _dmmf;
  private readonly _fetcher;
  private readonly _queryType;
  private readonly _rootField;
  private readonly _clientMethod;
  private readonly _args;
  private readonly _dataPath;
  private readonly _errorFormat;
  private readonly _measurePerformance?;
  private _isList;
  private _callsite;
  private _requestPromise?;
  constructor(_dmmf: DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
  readonly [Symbol.toStringTag]: 'PrismaClientPromise';

  orders<T extends FindManyordersArgs = {}>(args?: Subset<T, FindManyordersArgs>): CheckSelect<T, Promise<Array<orders>>, Promise<Array<ordersGetPayload<T>>>>;

  private get _document();
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | Promise<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | Promise<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | Promise<TResult>) | undefined | null): Promise<T | TResult>;
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): Promise<T>;
}

// Custom InputTypes

/**
 * products findOne
 */
export type FindOneproductsArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * Filter, which products to fetch.
  **/
  where: productsWhereUniqueInput
}


/**
 * products findFirst
 */
export type FindFirstproductsArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * Filter, which products to fetch.
  **/
  where?: productsWhereInput
  orderBy?: Enumerable<productsOrderByInput> | productsOrderByInput
  cursor?: productsWhereUniqueInput
  take?: number
  skip?: number
  distinct?: Enumerable<ProductsDistinctFieldEnum>
}


/**
 * products findMany
 */
export type FindManyproductsArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * Filter, which products to fetch.
  **/
  where?: productsWhereInput
  /**
   * Determine the order of the products to fetch.
  **/
  orderBy?: Enumerable<productsOrderByInput> | productsOrderByInput
  /**
   * Sets the position for listing products.
  **/
  cursor?: productsWhereUniqueInput
  /**
   * The number of products to fetch. If negative number, it will take products before the `cursor`.
  **/
  take?: number
  /**
   * Skip the first `n` products.
  **/
  skip?: number
  distinct?: Enumerable<ProductsDistinctFieldEnum>
}


/**
 * products create
 */
export type productsCreateArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * The data needed to create a products.
  **/
  data: productsCreateInput
}


/**
 * products update
 */
export type productsUpdateArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * The data needed to update a products.
  **/
  data: productsUpdateInput
  /**
   * Choose, which products to update.
  **/
  where: productsWhereUniqueInput
}


/**
 * products updateMany
 */
export type productsUpdateManyArgs = {
  data: productsUpdateManyMutationInput
  where?: productsWhereInput
}


/**
 * products upsert
 */
export type productsUpsertArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * The filter to search for the products to update in case it exists.
  **/
  where: productsWhereUniqueInput
  /**
   * In case the products found by the `where` argument doesn't exist, create a new products with this data.
  **/
  create: productsCreateInput
  /**
   * In case the products was found with the provided `where` argument, update it with this data.
  **/
  update: productsUpdateInput
}


/**
 * products delete
 */
export type productsDeleteArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
  /**
   * Filter which products to delete.
  **/
  where: productsWhereUniqueInput
}


/**
 * products deleteMany
 */
export type productsDeleteManyArgs = {
  where?: productsWhereInput
}


/**
 * products without action
 */
export type productsArgs = {
  /**
   * Select specific fields to fetch from the products
  **/
  select?: productsSelect | null
  /**
   * Choose, which related nodes to fetch as well.
  **/
  include?: productsInclude | null
}



/**
 * Deep Input Types
 */


export type customersWhereInput = {
  AND?: customersWhereInput | Enumerable<customersWhereInput>
  OR?: customersWhereInput | Enumerable<customersWhereInput>
  NOT?: customersWhereInput | Enumerable<customersWhereInput>
  id?: IntFilter | number
  firstname?: StringNullableFilter | string | null
  lastname?: StringNullableFilter | string | null
  email?: StringNullableFilter | string | null
  created_at?: DateTimeNullableFilter | Date | string | null
  updated_at?: DateTimeNullableFilter | Date | string | null
  stripe_id?: StringNullableFilter | string | null
  orders?: OrdersListRelationFilter
}

export type customersOrderByInput = {
  id?: SortOrder
  firstname?: SortOrder
  lastname?: SortOrder
  email?: SortOrder
  created_at?: SortOrder
  updated_at?: SortOrder
  stripe_id?: SortOrder
}

export type customersWhereUniqueInput = {
  id?: number
}

export type deliveriesWhereInput = {
  AND?: deliveriesWhereInput | Enumerable<deliveriesWhereInput>
  OR?: deliveriesWhereInput | Enumerable<deliveriesWhereInput>
  NOT?: deliveriesWhereInput | Enumerable<deliveriesWhereInput>
  id?: IntFilter | number
  phone?: StringNullableFilter | string | null
  lng?: FloatNullableFilter | number | null
  lat?: FloatNullableFilter | number | null
  is_delivered?: BoolNullableFilter | boolean | null
  created_at?: DateTimeNullableFilter | Date | string | null
  updated_at?: DateTimeNullableFilter | Date | string | null
  orders?: OrdersListRelationFilter
}

export type deliveriesOrderByInput = {
  id?: SortOrder
  phone?: SortOrder
  lng?: SortOrder
  lat?: SortOrder
  is_delivered?: SortOrder
  created_at?: SortOrder
  updated_at?: SortOrder
}

export type deliveriesWhereUniqueInput = {
  id?: number
}

export type ordersWhereInput = {
  AND?: ordersWhereInput | Enumerable<ordersWhereInput>
  OR?: ordersWhereInput | Enumerable<ordersWhereInput>
  NOT?: ordersWhereInput | Enumerable<ordersWhereInput>
  ref?: StringFilter | string
  shipping_status?: StringNullableFilter | string | null
  created_at?: DateTimeNullableFilter | Date | string | null
  updated_at?: DateTimeNullableFilter | Date | string | null
  product_id?: IntNullableFilter | number | null
  customer_id?: IntNullableFilter | number | null
  being_processed_at?: DateTimeNullableFilter | Date | string | null
  delivery_id?: IntNullableFilter | number | null
  ready_for_shipping_at?: DateTimeNullableFilter | Date | string | null
  in_transit_at?: DateTimeNullableFilter | Date | string | null
  shipped_at?: DateTimeNullableFilter | Date | string | null
  customers?: CustomersRelationFilter | customersWhereInput | null
  deliveries?: DeliveriesRelationFilter | deliveriesWhereInput | null
  products?: ProductsRelationFilter | productsWhereInput | null
}

export type ordersOrderByInput = {
  ref?: SortOrder
  shipping_status?: SortOrder
  created_at?: SortOrder
  updated_at?: SortOrder
  product_id?: SortOrder
  customer_id?: SortOrder
  being_processed_at?: SortOrder
  delivery_id?: SortOrder
  ready_for_shipping_at?: SortOrder
  in_transit_at?: SortOrder
  shipped_at?: SortOrder
}

export type ordersWhereUniqueInput = {
  ref?: string
}

export type productsWhereInput = {
  AND?: productsWhereInput | Enumerable<productsWhereInput>
  OR?: productsWhereInput | Enumerable<productsWhereInput>
  NOT?: productsWhereInput | Enumerable<productsWhereInput>
  id?: IntFilter | number
  created_at?: DateTimeNullableFilter | Date | string | null
  updated_at?: DateTimeNullableFilter | Date | string | null
  price?: FloatNullableFilter | number | null
  label?: StringNullableFilter | string | null
  picture?: StringNullableFilter | string | null
  orders?: OrdersListRelationFilter
}

export type productsOrderByInput = {
  id?: SortOrder
  created_at?: SortOrder
  updated_at?: SortOrder
  price?: SortOrder
  label?: SortOrder
  picture?: SortOrder
}

export type productsWhereUniqueInput = {
  id?: number
}

export type customersCreateInput = {
  firstname?: string | null
  lastname?: string | null
  email?: string | null
  created_at?: Date | string | null
  updated_at?: Date | string | null
  stripe_id?: string | null
  orders?: ordersCreateManyWithoutCustomersInput
}

export type customersUpdateInput = {
  firstname?: string | NullableStringFieldUpdateOperationsInput | null
  lastname?: string | NullableStringFieldUpdateOperationsInput | null
  email?: string | NullableStringFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  stripe_id?: string | NullableStringFieldUpdateOperationsInput | null
  orders?: ordersUpdateManyWithoutCustomersInput
}

export type customersUpdateManyMutationInput = {
  firstname?: string | NullableStringFieldUpdateOperationsInput | null
  lastname?: string | NullableStringFieldUpdateOperationsInput | null
  email?: string | NullableStringFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  stripe_id?: string | NullableStringFieldUpdateOperationsInput | null
}

export type deliveriesCreateInput = {
  phone?: string | null
  lng?: number | null
  lat?: number | null
  is_delivered?: boolean | null
  created_at?: Date | string | null
  updated_at?: Date | string | null
  orders?: ordersCreateManyWithoutDeliveriesInput
}

export type deliveriesUpdateInput = {
  phone?: string | NullableStringFieldUpdateOperationsInput | null
  lng?: number | NullableFloatFieldUpdateOperationsInput | null
  lat?: number | NullableFloatFieldUpdateOperationsInput | null
  is_delivered?: boolean | NullableBoolFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  orders?: ordersUpdateManyWithoutDeliveriesInput
}

export type deliveriesUpdateManyMutationInput = {
  phone?: string | NullableStringFieldUpdateOperationsInput | null
  lng?: number | NullableFloatFieldUpdateOperationsInput | null
  lat?: number | NullableFloatFieldUpdateOperationsInput | null
  is_delivered?: boolean | NullableBoolFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type ordersCreateInput = {
  ref?: string
  shipping_status?: string | null
  created_at?: Date | string | null
  updated_at?: Date | string | null
  being_processed_at?: Date | string | null
  ready_for_shipping_at?: Date | string | null
  in_transit_at?: Date | string | null
  shipped_at?: Date | string | null
  customers?: customersCreateOneWithoutOrdersInput
  deliveries?: deliveriesCreateOneWithoutOrdersInput
  products?: productsCreateOneWithoutOrdersInput
}

export type ordersUpdateInput = {
  ref?: string | StringFieldUpdateOperationsInput
  shipping_status?: string | NullableStringFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  being_processed_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  ready_for_shipping_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  in_transit_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  shipped_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  customers?: customersUpdateOneWithoutOrdersInput
  deliveries?: deliveriesUpdateOneWithoutOrdersInput
  products?: productsUpdateOneWithoutOrdersInput
}

export type ordersUpdateManyMutationInput = {
  ref?: string | StringFieldUpdateOperationsInput
  shipping_status?: string | NullableStringFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  being_processed_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  ready_for_shipping_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  in_transit_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  shipped_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type productsCreateInput = {
  created_at?: Date | string | null
  updated_at?: Date | string | null
  price?: number | null
  label?: string | null
  picture?: string | null
  orders?: ordersCreateManyWithoutProductsInput
}

export type productsUpdateInput = {
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  price?: number | NullableFloatFieldUpdateOperationsInput | null
  label?: string | NullableStringFieldUpdateOperationsInput | null
  picture?: string | NullableStringFieldUpdateOperationsInput | null
  orders?: ordersUpdateManyWithoutProductsInput
}

export type productsUpdateManyMutationInput = {
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  price?: number | NullableFloatFieldUpdateOperationsInput | null
  label?: string | NullableStringFieldUpdateOperationsInput | null
  picture?: string | NullableStringFieldUpdateOperationsInput | null
}

export type IntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type StringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  mode?: QueryMode
  not?: string | NestedStringNullableFilter | null
}

export type DateTimeNullableFilter = {
  equals?: Date | string | null
  in?: Enumerable<Date> | Enumerable<string> | null
  notIn?: Enumerable<Date> | Enumerable<string> | null
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: Date | string | NestedDateTimeNullableFilter | null
}

export type OrdersListRelationFilter = {
  every?: ordersWhereInput
  some?: ordersWhereInput
  none?: ordersWhereInput
}

export type FloatNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatNullableFilter | null
}

export type BoolNullableFilter = {
  equals?: boolean | null
  not?: boolean | NestedBoolNullableFilter | null
}

export type StringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  mode?: QueryMode
  not?: string | NestedStringFilter
}

export type IntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntNullableFilter | null
}

export type CustomersRelationFilter = {
  is?: customersWhereInput | null
  isNot?: customersWhereInput | null
}

export type DeliveriesRelationFilter = {
  is?: deliveriesWhereInput | null
  isNot?: deliveriesWhereInput | null
}

export type ProductsRelationFilter = {
  is?: productsWhereInput | null
  isNot?: productsWhereInput | null
}

export type ordersCreateManyWithoutCustomersInput = {
  create?: ordersCreateWithoutCustomersInput | Enumerable<ordersCreateWithoutCustomersInput>
  connect?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
}

export type NullableStringFieldUpdateOperationsInput = {
  set?: string | null
}

export type NullableDateTimeFieldUpdateOperationsInput = {
  set?: Date | string | null
}

export type ordersUpdateManyWithoutCustomersInput = {
  create?: ordersCreateWithoutCustomersInput | Enumerable<ordersCreateWithoutCustomersInput>
  connect?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  set?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  disconnect?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  delete?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  update?: ordersUpdateWithWhereUniqueWithoutCustomersInput | Enumerable<ordersUpdateWithWhereUniqueWithoutCustomersInput>
  updateMany?: ordersUpdateManyWithWhereNestedInput | Enumerable<ordersUpdateManyWithWhereNestedInput>
  deleteMany?: ordersScalarWhereInput | Enumerable<ordersScalarWhereInput>
  upsert?: ordersUpsertWithWhereUniqueWithoutCustomersInput | Enumerable<ordersUpsertWithWhereUniqueWithoutCustomersInput>
}

export type ordersCreateManyWithoutDeliveriesInput = {
  create?: ordersCreateWithoutDeliveriesInput | Enumerable<ordersCreateWithoutDeliveriesInput>
  connect?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
}

export type NullableFloatFieldUpdateOperationsInput = {
  set?: number | null
}

export type NullableBoolFieldUpdateOperationsInput = {
  set?: boolean | null
}

export type ordersUpdateManyWithoutDeliveriesInput = {
  create?: ordersCreateWithoutDeliveriesInput | Enumerable<ordersCreateWithoutDeliveriesInput>
  connect?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  set?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  disconnect?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  delete?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  update?: ordersUpdateWithWhereUniqueWithoutDeliveriesInput | Enumerable<ordersUpdateWithWhereUniqueWithoutDeliveriesInput>
  updateMany?: ordersUpdateManyWithWhereNestedInput | Enumerable<ordersUpdateManyWithWhereNestedInput>
  deleteMany?: ordersScalarWhereInput | Enumerable<ordersScalarWhereInput>
  upsert?: ordersUpsertWithWhereUniqueWithoutDeliveriesInput | Enumerable<ordersUpsertWithWhereUniqueWithoutDeliveriesInput>
}

export type customersCreateOneWithoutOrdersInput = {
  create?: customersCreateWithoutOrdersInput
  connect?: customersWhereUniqueInput
}

export type deliveriesCreateOneWithoutOrdersInput = {
  create?: deliveriesCreateWithoutOrdersInput
  connect?: deliveriesWhereUniqueInput
}

export type productsCreateOneWithoutOrdersInput = {
  create?: productsCreateWithoutOrdersInput
  connect?: productsWhereUniqueInput
}

export type StringFieldUpdateOperationsInput = {
  set?: string
}

export type customersUpdateOneWithoutOrdersInput = {
  create?: customersCreateWithoutOrdersInput
  connect?: customersWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: customersUpdateWithoutOrdersDataInput
  upsert?: customersUpsertWithoutOrdersInput
}

export type deliveriesUpdateOneWithoutOrdersInput = {
  create?: deliveriesCreateWithoutOrdersInput
  connect?: deliveriesWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: deliveriesUpdateWithoutOrdersDataInput
  upsert?: deliveriesUpsertWithoutOrdersInput
}

export type productsUpdateOneWithoutOrdersInput = {
  create?: productsCreateWithoutOrdersInput
  connect?: productsWhereUniqueInput
  disconnect?: boolean
  delete?: boolean
  update?: productsUpdateWithoutOrdersDataInput
  upsert?: productsUpsertWithoutOrdersInput
}

export type ordersCreateManyWithoutProductsInput = {
  create?: ordersCreateWithoutProductsInput | Enumerable<ordersCreateWithoutProductsInput>
  connect?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
}

export type ordersUpdateManyWithoutProductsInput = {
  create?: ordersCreateWithoutProductsInput | Enumerable<ordersCreateWithoutProductsInput>
  connect?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  set?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  disconnect?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  delete?: ordersWhereUniqueInput | Enumerable<ordersWhereUniqueInput>
  update?: ordersUpdateWithWhereUniqueWithoutProductsInput | Enumerable<ordersUpdateWithWhereUniqueWithoutProductsInput>
  updateMany?: ordersUpdateManyWithWhereNestedInput | Enumerable<ordersUpdateManyWithWhereNestedInput>
  deleteMany?: ordersScalarWhereInput | Enumerable<ordersScalarWhereInput>
  upsert?: ordersUpsertWithWhereUniqueWithoutProductsInput | Enumerable<ordersUpsertWithWhereUniqueWithoutProductsInput>
}

export type NestedIntFilter = {
  equals?: number
  in?: Enumerable<number>
  notIn?: Enumerable<number>
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntFilter
}

export type NestedStringNullableFilter = {
  equals?: string | null
  in?: Enumerable<string> | null
  notIn?: Enumerable<string> | null
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringNullableFilter | null
}

export type NestedDateTimeNullableFilter = {
  equals?: Date | string | null
  in?: Enumerable<Date> | Enumerable<string> | null
  notIn?: Enumerable<Date> | Enumerable<string> | null
  lt?: Date | string
  lte?: Date | string
  gt?: Date | string
  gte?: Date | string
  not?: Date | string | NestedDateTimeNullableFilter | null
}

export type NestedFloatNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedFloatNullableFilter | null
}

export type NestedBoolNullableFilter = {
  equals?: boolean | null
  not?: boolean | NestedBoolNullableFilter | null
}

export type NestedStringFilter = {
  equals?: string
  in?: Enumerable<string>
  notIn?: Enumerable<string>
  lt?: string
  lte?: string
  gt?: string
  gte?: string
  contains?: string
  startsWith?: string
  endsWith?: string
  not?: string | NestedStringFilter
}

export type NestedIntNullableFilter = {
  equals?: number | null
  in?: Enumerable<number> | null
  notIn?: Enumerable<number> | null
  lt?: number
  lte?: number
  gt?: number
  gte?: number
  not?: number | NestedIntNullableFilter | null
}

export type ordersCreateWithoutCustomersInput = {
  ref?: string
  shipping_status?: string | null
  created_at?: Date | string | null
  updated_at?: Date | string | null
  being_processed_at?: Date | string | null
  ready_for_shipping_at?: Date | string | null
  in_transit_at?: Date | string | null
  shipped_at?: Date | string | null
  deliveries?: deliveriesCreateOneWithoutOrdersInput
  products?: productsCreateOneWithoutOrdersInput
}

export type ordersUpdateWithWhereUniqueWithoutCustomersInput = {
  where: ordersWhereUniqueInput
  data: ordersUpdateWithoutCustomersDataInput
}

export type ordersUpdateManyWithWhereNestedInput = {
  where: ordersScalarWhereInput
  data: ordersUpdateManyDataInput
}

export type ordersScalarWhereInput = {
  AND?: ordersScalarWhereInput | Enumerable<ordersScalarWhereInput>
  OR?: ordersScalarWhereInput | Enumerable<ordersScalarWhereInput>
  NOT?: ordersScalarWhereInput | Enumerable<ordersScalarWhereInput>
  ref?: StringFilter | string
  shipping_status?: StringNullableFilter | string | null
  created_at?: DateTimeNullableFilter | Date | string | null
  updated_at?: DateTimeNullableFilter | Date | string | null
  product_id?: IntNullableFilter | number | null
  customer_id?: IntNullableFilter | number | null
  being_processed_at?: DateTimeNullableFilter | Date | string | null
  delivery_id?: IntNullableFilter | number | null
  ready_for_shipping_at?: DateTimeNullableFilter | Date | string | null
  in_transit_at?: DateTimeNullableFilter | Date | string | null
  shipped_at?: DateTimeNullableFilter | Date | string | null
}

export type ordersUpsertWithWhereUniqueWithoutCustomersInput = {
  where: ordersWhereUniqueInput
  update: ordersUpdateWithoutCustomersDataInput
  create: ordersCreateWithoutCustomersInput
}

export type ordersCreateWithoutDeliveriesInput = {
  ref?: string
  shipping_status?: string | null
  created_at?: Date | string | null
  updated_at?: Date | string | null
  being_processed_at?: Date | string | null
  ready_for_shipping_at?: Date | string | null
  in_transit_at?: Date | string | null
  shipped_at?: Date | string | null
  customers?: customersCreateOneWithoutOrdersInput
  products?: productsCreateOneWithoutOrdersInput
}

export type ordersUpdateWithWhereUniqueWithoutDeliveriesInput = {
  where: ordersWhereUniqueInput
  data: ordersUpdateWithoutDeliveriesDataInput
}

export type ordersUpsertWithWhereUniqueWithoutDeliveriesInput = {
  where: ordersWhereUniqueInput
  update: ordersUpdateWithoutDeliveriesDataInput
  create: ordersCreateWithoutDeliveriesInput
}

export type customersCreateWithoutOrdersInput = {
  firstname?: string | null
  lastname?: string | null
  email?: string | null
  created_at?: Date | string | null
  updated_at?: Date | string | null
  stripe_id?: string | null
}

export type deliveriesCreateWithoutOrdersInput = {
  phone?: string | null
  lng?: number | null
  lat?: number | null
  is_delivered?: boolean | null
  created_at?: Date | string | null
  updated_at?: Date | string | null
}

export type productsCreateWithoutOrdersInput = {
  created_at?: Date | string | null
  updated_at?: Date | string | null
  price?: number | null
  label?: string | null
  picture?: string | null
}

export type customersUpdateWithoutOrdersDataInput = {
  firstname?: string | NullableStringFieldUpdateOperationsInput | null
  lastname?: string | NullableStringFieldUpdateOperationsInput | null
  email?: string | NullableStringFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  stripe_id?: string | NullableStringFieldUpdateOperationsInput | null
}

export type customersUpsertWithoutOrdersInput = {
  update: customersUpdateWithoutOrdersDataInput
  create: customersCreateWithoutOrdersInput
}

export type deliveriesUpdateWithoutOrdersDataInput = {
  phone?: string | NullableStringFieldUpdateOperationsInput | null
  lng?: number | NullableFloatFieldUpdateOperationsInput | null
  lat?: number | NullableFloatFieldUpdateOperationsInput | null
  is_delivered?: boolean | NullableBoolFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type deliveriesUpsertWithoutOrdersInput = {
  update: deliveriesUpdateWithoutOrdersDataInput
  create: deliveriesCreateWithoutOrdersInput
}

export type productsUpdateWithoutOrdersDataInput = {
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  price?: number | NullableFloatFieldUpdateOperationsInput | null
  label?: string | NullableStringFieldUpdateOperationsInput | null
  picture?: string | NullableStringFieldUpdateOperationsInput | null
}

export type productsUpsertWithoutOrdersInput = {
  update: productsUpdateWithoutOrdersDataInput
  create: productsCreateWithoutOrdersInput
}

export type ordersCreateWithoutProductsInput = {
  ref?: string
  shipping_status?: string | null
  created_at?: Date | string | null
  updated_at?: Date | string | null
  being_processed_at?: Date | string | null
  ready_for_shipping_at?: Date | string | null
  in_transit_at?: Date | string | null
  shipped_at?: Date | string | null
  customers?: customersCreateOneWithoutOrdersInput
  deliveries?: deliveriesCreateOneWithoutOrdersInput
}

export type ordersUpdateWithWhereUniqueWithoutProductsInput = {
  where: ordersWhereUniqueInput
  data: ordersUpdateWithoutProductsDataInput
}

export type ordersUpsertWithWhereUniqueWithoutProductsInput = {
  where: ordersWhereUniqueInput
  update: ordersUpdateWithoutProductsDataInput
  create: ordersCreateWithoutProductsInput
}

export type ordersUpdateWithoutCustomersDataInput = {
  ref?: string | StringFieldUpdateOperationsInput
  shipping_status?: string | NullableStringFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  being_processed_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  ready_for_shipping_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  in_transit_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  shipped_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  deliveries?: deliveriesUpdateOneWithoutOrdersInput
  products?: productsUpdateOneWithoutOrdersInput
}

export type ordersUpdateManyDataInput = {
  ref?: string | StringFieldUpdateOperationsInput
  shipping_status?: string | NullableStringFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  being_processed_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  ready_for_shipping_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  in_transit_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  shipped_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
}

export type ordersUpdateWithoutDeliveriesDataInput = {
  ref?: string | StringFieldUpdateOperationsInput
  shipping_status?: string | NullableStringFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  being_processed_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  ready_for_shipping_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  in_transit_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  shipped_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  customers?: customersUpdateOneWithoutOrdersInput
  products?: productsUpdateOneWithoutOrdersInput
}

export type ordersUpdateWithoutProductsDataInput = {
  ref?: string | StringFieldUpdateOperationsInput
  shipping_status?: string | NullableStringFieldUpdateOperationsInput | null
  created_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  updated_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  being_processed_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  ready_for_shipping_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  in_transit_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  shipped_at?: Date | string | NullableDateTimeFieldUpdateOperationsInput | null
  customers?: customersUpdateOneWithoutOrdersInput
  deliveries?: deliveriesUpdateOneWithoutOrdersInput
}

/**
 * Batch Payload for updateMany & deleteMany
 */

export type BatchPayload = {
  count: number
}

/**
 * DMMF
 */
export declare const dmmf: DMMF.Document;
export {};
